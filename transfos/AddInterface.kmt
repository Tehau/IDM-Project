/* $Id:$ 
 * Creation : December 10, 2013
 * Licence  : EPL 
 * Copyright:
 * Authors  : 
 *            ttsing
 */
@mainClass "transfos::Main"
@mainOperation "main"

//http://web.univ-pau.fr/~ecariou/cours/idm/docs/KerMeta-Manual.pdf
package transfos;

require kermeta

// meta-modele du diagramme de classe
require "platform:/resource/ClassDiagram/metaModels/ClassDiagram.ecore"

// fonctions utilitaires Kermeta associees au MM de diagramme de classe
require "platform:/resource/ClassDiagram/metaModels/ClassDiagramUtil.kmt"


using kermeta::persistence
using kermeta::exceptions
using kermeta::standard

// package du meta-modele
using ClassDiagram

// package des fonctions utilitaires
using ClassDiagramUtil

class Main
{
	// hack pour avoir n'importe ou une reference sur le type void
	reference voidT : VoidType
	
	
	operation AddInterface(source : ClassDiagram::ModelBase) : Void is do
		var i : Integer init 1
		var j : Integer init 1
		var methodNames : seq Method[1..*] init Sequence<Method>.new
		source.allClasses.each{c1|
			source.allClasses.each{c2|
				if( i < j )
				then
					CheckInterface(c1,c2,methodNames)
				else
					stdio.writeln("Same Class or Already check")
				end
				j := j+1
			}
			j := 1
			i := i+1
		}
		MakeInterface(methodNames)
	end
	
	operation CheckInterface(c1 : ClassDiagram::Class, c2 : ClassDiagram::Class, methodNames : Sequence<Method> ) : Void is do
		var check : Boolean init true
		if(c1.name.equals(c2.name) == false)
		then
			stdio.writeln("C1 : "+c1.name)
			stdio.writeln("C2 : "+c2.name)
			c1.methods.each{m1|
				c2.methods.each{m2|
					if(asSameMethod(m1,m2))
					then
						if(methodNames.size() == 0)
						then
							methodNames.add(m1)
						else
							check := false
							methodNames.each{m|
								if(m.name.equals(m1.name))
								then
									check := true
								end
							}
							if(check == false)
							then
								methodNames.add(m1)
							end
						end
					end
				}
			}
		else
			stdio.writeln("Same Class dont add Interface")
		end
		
	end
	
	// check if same method
	operation asSameMethod(m1 : ClassDiagram::Method, m2 : ClassDiagram::Method) : Boolean is do
		var check : Boolean init true
		var i : Integer init 0
		var j : Integer init 0
		
		if(m1.name.equals(m2.name))
		then
			m1.parameters.each{p1|
				m2.parameters.each{p2|
					stdio.writeln("	Nom : "+ m1.name +" parametre : " + p1.name +" type : " + p1.type.name)
					stdio.writeln("	Nom : "+ m2.name +" parametre : " + p2.name +" type : " + p2.type.name)
					if(i == j and check == true)
					then
						check := p1.type.name.equals(p2.type.name)
					end
					j := j+1
					stdio.writeln("	Check : "+p1.type.name.equals(p2.type.name).toString())
				}
				i := i+1
				j := 0
			}
			if(m1.returnType.name.equals(m2.returnType.name) == false)
			then
				check := false
			end
		else
			check := false
		end
		result := check
	end
	
	operation MakeInterface(methodNames : Sequence<Method>) : Void is do
		stdio.writeln("Make Interface")
		//TODO 	Faire des interfaces avec les Methodes dans le tableau
		//		Faire le merge des interfaces si des classes utilisent les mÃªme
		var int : ClassDiagram::Interface
		methodNames.each{m|
			int := ClassDiagram::Interface.new
			int.name := "set" + m.name.substring(0,1).toUpperCase + m.name.substring(1,m.name.size)
			//int.
		}
	end
	
	
	
	operation main() : Void is do 

		// creation of the util object for loading/saving/printing models
		var util : ClassDiagramUtil::Util init ClassDiagramUtil::Util.new
		
		var source : ClassDiagram::ModelBase
		var target : ClassDiagram::ModelBase
		
		source := util.loadModel("platform:/resource/ClassDiagram/models/ModelBase.xmi")
		voidT := source.voidT
		
		stdio.writeln(" === modele source ===")
		AddInterface(source)
		
	end

}